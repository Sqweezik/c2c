"""
AIC Gachapon Exploit - Direct RNG Prediction
=============================================

.NET System.Random legacy subtractive generator recurrence on outputs:
  output[n] = (output[n-55] - output[n-34]) mod 2147483647

Per tick, 25 InternalSample() calls in order:
  [0-2]   3x reel (Next(10))         — partially observable
  [3]     1x jackpot (Next(1000000))  — partially observable
  [4-19]  16x sampleInts (Next(MAX)) — FULLY observable (raw InternalSample values)
  [20-23] 4x sampleBytes (NextBytes) — low 8 bits observable
  [24]    1x redeemCode (Next(10M))  — HIDDEN, this is what we predict

Global output position for tick k:
  tick k sampleInts[j] = position 4 + 25*k + j  (j = 0..15)
  tick k redeemCode    = position 24 + 25*k

Using recurrence: s[24+25k] = s[24+25k - 55] - s[24+25k - 34]
                             = s[25k - 31] - s[25k - 10]

For k >= 2:
  25k-31: for k=2 → 19 (= tick 0 sampleInts[15])     [OK] known
  25k-10: for k=2 → 40 (= tick 1 sampleInts[11])     [OK] known
  
General formula:
  25k-31 = 25(k-2) + 19 → sampleInts[15] of tick (k-2)
  25k-10 = 25(k-1) + 15 → sampleInts[11] of tick (k-1)  
  Wait, 25(k-1)+15 = 25k-10. And 4+25(k-1)+11 = 25k-10. So sampleInts[11] of tick k-1.

So: redeemCode_raw = (sampleInts[15] of tick k-2) - (sampleInts[11] of tick k-1)
    redeemCode_raw = redeemCode_raw mod 2147483647
    redeemCode = int(redeemCode_raw / 2147483647.0 * 10000000)
"""

import requests
import sys
import time

MBIG = 2147483647

def exploit(url):
    s = requests.Session()
    
    # 1. Fetch recent frames
    print("[*] Fetching recent frames...")
    r = s.get(f"{url}/api/recent/30")
    if r.status_code != 200:
        print(f"[-] Failed to get recent: {r.status_code}")
        return
    recent = r.json()
    recent.sort(key=lambda f: f['tickId'])
    print(f"[+] Got {len(recent)} frames, ticks {recent[0]['tickId']}..{recent[-1]['tickId']}")
    
    # 2. Get current frame
    r = s.get(f"{url}/api/frame")
    current = r.json()
    current_tick = current['tickId']
    print(f"[+] Current tick: {current_tick}")
    
    # Build a dict of frames by tickId
    frames = {f['tickId']: f for f in recent}
    frames[current_tick] = current
    
    # 3. Find a target tick k where we have frames for k, k-1, and k-2
    target_tick = None
    for k in sorted(frames.keys(), reverse=True):
        if (k-1) in frames and (k-2) in frames:
            target_tick = k
            break
    
    if not target_tick:
        print("[*] Need consecutive ticks, waiting...")
        for attempt in range(5):
            time.sleep(3)
            r = s.get(f"{url}/api/frame")
            f = r.json()
            frames[f['tickId']] = f
            r = s.get(f"{url}/api/recent/30")
            for ff in r.json():
                frames[ff['tickId']] = ff
            
            for k in sorted(frames.keys(), reverse=True):
                if (k-1) in frames and (k-2) in frames:
                    target_tick = k
                    break
            if target_tick:
                break
    
    if not target_tick:
        print("[-] Could not find 3 consecutive ticks.")
        return
    
    print(f"\n[+] Target tick: {target_tick}")
    
    # 4. Compute redeemCode using the recurrence
    frame_k2 = frames[target_tick - 2]
    frame_k1 = frames[target_tick - 1]
    frame_k  = frames[target_tick]
    
    val_a = frame_k2['sampleInts'][15]  # position 25(k-2)+19 = 25k-31
    val_b = frame_k1['sampleInts'][11]  # position 25(k-1)+15 = 25k-10
    
    print(f"[+] sampleInts[15] of tick {target_tick-2}: {val_a}")
    print(f"[+] sampleInts[11] of tick {target_tick-1}: {val_b}")
    
    raw = (val_a - val_b) % MBIG
    redeem_code = int(raw * 10000000.0 / MBIG)
    
    print(f"[+] Computed raw value: {raw}")
    print(f"[+] Predicted redeemCode: {redeem_code}")
    
    # 5. Verify using additional constraints before submitting
    # Let's also verify the recurrence on known values
    # For sampleInts: position 4+25k+j
    # s[4+25k+j] = s[4+25k+j-55] - s[4+25k+j-34] = s[25k+j-51] - s[25k+j-30]
    # For k=2, j=0: s[50+0-51]=-1 → need k>=3 or larger j
    # For k=2, j=12: s[50+12-51]=s[11], s[50+12-30]=s[32] 
    #   s[11]=tick0.sampleInts[7], s[32]=tick1.sampleInts[3]
    #   predicted = (tick0.sampleInts[7] - tick1.sampleInts[3]) % MBIG
    #   actual = tick2.sampleInts[12]
    
    if target_tick >= 2:
        # Verify recurrence
        frame_t0 = frames.get(target_tick - 2)
        frame_t1 = frames.get(target_tick - 1)
        frame_t2 = frames.get(target_tick)
        
        if frame_t0 and frame_t1 and frame_t2:
            # For j=12 in tick k=target: position = 4+25k+12 = 25k+16
            # n-55 = 25k+16-55 = 25k-39 = 25(k-2)+11 → tick(k-2) sampleInts[7]
            # n-34 = 25k+16-34 = 25k-18 = 25(k-1)+7 → tick(k-1) sampleInts[3]
            v55 = frame_t0['sampleInts'][7]   # position 25(k-2)+11
            v34 = frame_t1['sampleInts'][3]   # position 25(k-1)+7
            predicted = (v55 - v34) % MBIG
            actual = frame_t2['sampleInts'][12]
            
            print(f"\n[*] Verification: predicted sampleInts[12] of tick {target_tick} = {predicted}")
            print(f"[*] Verification: actual    sampleInts[12] of tick {target_tick} = {actual}")
            
            if predicted == actual:
                print("[+] [OK] Recurrence VERIFIED! Our prediction should be correct.")
            else:
                print("[-] [FAIL] Recurrence MISMATCH! Something is wrong with our model.")
                print("[*] Trying alternative recurrence: s[n] = s[n-21] - s[n-55]")
                # Alternative: s[n] = s[n-21] - s[n-55]
                # position n = 25k+16
                # n-21 = 25k-5 = 25(k-1)+20 → NextBytes[0] of tick k-1 (only low 8 bits known)
                # n-55 = 25k-39 = 25(k-2)+11 → sampleInts[7] of tick k-2
                
                # For redeemCode: n = 25k+24
                # n-21 = 25k+3 → jackpot of tick k (known as jackpot_preview, ~2147 candidates)
                # n-55 = 25k-31 = 25(k-2)+19 → sampleInts[15] of tick k-2
                
                # Let me test with values where both taps are in known ranges
                # For j such that both 25k+4+j-21 and 25k+4+j-55 are in sampleInts ranges
                # n-21 = 25k+j-17. In tick k-1 sampleInts: need 4+25(k-1) <= 25k+j-17 <= 19+25(k-1)
                #   i.e., 25k-21 <= 25k+j-17 <= 25k-6  → -4 <= j <=11
                # n-55 = 25k+j-51. In tick k-3 sampleInts: need 4+25(k-3) <= 25k+j-51 <= 19+25(k-3)
                #   i.e., 25k-71 <= 25k+j-51 <= 25k-56  → -20 <= j <= -5
                # These don't overlap, so no j works for both taps in known regions
                
                # For n-55 in tick k-2 sampleInts: 4+25(k-2) <= 25k+j-51 <= 19+25(k-2)
                #   25k-46 <= 25k+j-51 <= 25k-31  →  5 <= j <= 20
                # Combined with n-21 in tick k-1 sampleInts: -4 <= j <= 11
                # Overlap: j = 5..11
                
                for j in range(5, 12):
                    n_minus_21 = 25*(target_tick-1) + 4 + (j - 5 + 8)  # tick k-1, sampleInts[j-4-1+8]
                    # Actually let me recompute
                    pos_n = 4 + 25*target_tick + j
                    pos_n21 = pos_n - 21  # = 25k + j - 17
                    pos_n55 = pos_n - 55  # = 25k + j - 51
                    
                    # pos_n21 in tick k-1 sampleInts: index = pos_n21 - (4 + 25*(target_tick-1))
                    idx_21 = pos_n21 - (4 + 25*(target_tick-1))
                    # pos_n55 in tick k-2 sampleInts: index = pos_n55 - (4 + 25*(target_tick-2))
                    idx_55 = pos_n55 - (4 + 25*(target_tick-2))
                    
                    if 0 <= idx_21 <= 15 and 0 <= idx_55 <= 15:
                        v21 = frame_t1['sampleInts'][idx_21]
                        v55_alt = frame_t0['sampleInts'][idx_55]
                        pred_alt = (v21 - v55_alt) % MBIG
                        actual_j = frame_t2['sampleInts'][j]
                        match = "[OK]" if pred_alt == actual_j else "[FAIL]"
                        print(f"  s[n]-alt recurrence j={j}: s[n-21](idx{idx_21})={v21}, s[n-55](idx{idx_55})={v55_alt}, pred={pred_alt}, actual={actual_j} {match}")
                
                # Also compute redeemCode with alternative recurrence
                # s[24+25k] = s[3+25k] - s[25k-31]
                # s[3+25k] from jackpot: jackpot = int(s * 1e6 / MBIG)
                jp = frame_k['jackpotPreview']
                s_jp_min = 0
                while int(s_jp_min * 1000000.0 / MBIG) < jp:
                    s_jp_min += 1
                s_jp_max = s_jp_min
                while int((s_jp_max + 1) * 1000000.0 / MBIG) == jp:
                    s_jp_max += 1
                
                val_55 = frame_k2['sampleInts'][15]  # position 25(k-2)+19 = 25k-31
                redeem_alt_codes = set()
                for s_jp in range(s_jp_min, s_jp_max + 1):
                    raw_alt = (s_jp - val_55) % MBIG
                    rc = int(raw_alt * 10000000.0 / MBIG)
                    redeem_alt_codes.add(rc)
                
                redeem_alt_list = sorted(redeem_alt_codes)
                print(f"\n[+] Alternative recurrence: {len(redeem_alt_list)} candidate codes")
                print(f"[+] Candidates: {redeem_alt_list[:20]}{'...' if len(redeem_alt_list) > 20 else ''}")
                
                # Try alternative codes
                for code in redeem_alt_list:
                    r2 = s.post(f"{url}/api/redeem", json={'tickId': target_tick, 'code': code})
                    if r2.status_code == 200:
                        data = r2.json()
                        print(f"[+] SUCCESS with alt code {code}! Response: {data}")
                        return
                    elif r2.status_code == 429:
                        print("[-] Rate limited, waiting...")
                        time.sleep(2)
                
                print("[-] Alt codes also failed.")
                return
    
    # 6. Submit the predicted redeemCode
    print(f"\n[*] Submitting redeemCode {redeem_code} for tick {target_tick}...")
    r = s.post(f"{url}/api/redeem", json={'tickId': target_tick, 'code': redeem_code})
    print(f"[+] Response: {r.status_code}")
    
    try:
        data = r.json()
        print(f"[+] Data: {data}")
        if r.status_code == 200:
            print(f"\n[+] FLAG OBTAINED!")
        else:
            # Try neighboring codes (off-by-one due to floating point)
            for delta in [-1, 1, -2, 2]:
                alt_code = redeem_code + delta
                if alt_code < 0 or alt_code >= 10000000:
                    continue
                r2 = s.post(f"{url}/api/redeem", json={'tickId': target_tick, 'code': alt_code})
                if r2.status_code == 200:
                    print(f"[+] SUCCESS with code {alt_code}!")
                    print(f"[+] Data: {r2.json()}")
                    return
    except:
        print(r.text)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python exploit_gachapon.py <url>")
        sys.exit(1)
    
    url = sys.argv[1].rstrip('/')
    exploit(url)
